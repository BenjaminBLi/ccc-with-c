/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Neb
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
#define fori(i, st, en) for(int i = st; i < en; i++)
#define rfori(i, st, en) for(int i = st; i >= en; i--)
#define f first
#define s second
#define pb push_back
using namespace std;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef long long ll;
typedef vector<ii> vii;

int N, M, T, grid[60][60], best, cnt, dr[4] = {1, -1, 0, 0}, dc[4] = {0, 0, 1, -1};
bool visited[60][60];
bool comp(ii &a, ii &b){
    return grid[a.f][a.s] > grid[b.f][b.s];
}

class a {
public:
    void dfs(int r, int c){
        visited[r][c] = true;
        int nr, nc;
        bool flag = false;

        fori(i, 0, 4){
            nr = r+dr[i];
            nc = c+dc[i];
            if(nr > N || nc > M || nr < 0 || nc < 0) continue;
            if(grid[nr][nc] < grid[r][c]){
                dfs(nr, nc);
                flag = true;
            }
        }
        if(!flag) cnt++;
    }
    void solve(std::istream& in, std::ostream& out) {
        in >> T;
        fori(i, 0, 60) fori(j, 0, 60) grid[i][j] = 1000;
        fori(t, 1, T+1){
            in >> N >> M;
            vii st;
            fori(i, 1, N+1) fori(j, 1, M+1) {
                    visited[i][j] = false;
                    st.pb(ii(i, j));
                    in >> grid[i][j];
                }
            sort(st.begin(), st.end(), comp);
            int tot = 0;
            for(ii b : st){
                if(visited[b.f][b.s]) continue;
                cnt = 0;
                dfs(b.f, b.s);
                tot += cnt;
            }
            out << "Case #" << t << ": " << tot << "\n";
            //cout << "END CASE" << endl;
        }
    }
};


int main() {
	a solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
